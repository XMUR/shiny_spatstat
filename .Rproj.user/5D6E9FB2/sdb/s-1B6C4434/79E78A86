{
    "contents" : "\n# This is the server logic for a Shiny web application.\n# You can find out more about building applications with Shiny here:\n#\n# http://shiny.rstudio.com\n#\n\nlibrary(shiny)\nlibrary(spatstat)\nlibrary(rCharts)\nlibrary(leaflet)\nlibrary(htmlwidgets)\n\nshinyServer(function(input, output, session) {\n\n    output$piechart <- renderChart2({\n        p5 <- nPlot(~ marks, data = point.data, type = 'pieChart')\n        p5$chart(donut = TRUE)\n        p5\n        return(p5)\n    })\n    \n    output$chart1 <- renderChart2({\n        p1 <- nPlot(x ~ y, group=\"marks\", data = point.data, type = \"scatterChart\")\n        p1$chart(tooltipContent = \"#! function(key, x, y, e){ \n                                      return 'Mark: ' + e.point.marks\n                                    } !#\")\n        p1$chart(color = c('#6495ED', '#CDC8B1'))\n        return(p1)\n    })\n    \n    output$scatterPlot <- downloadHandler(\n        filename = \"scatterplot.html\",\n        # a function that actually opens a connection to a pdf and print the result to it\n        content = function(file) { # this function must take at least an input variable, namely the filename of the file to save\n            p1 <- nPlot(x ~ y, group=\"marks\", data = point.data, type = \"scatterChart\")\n            p1$chart(tooltipContent = \"#! function(key, x, y, e){ \n                                      return 'Mark: ' + e.point.marks\n                                    } !#\")\n            p1$chart(color = c('#6495ED', '#CDC8B1'))\n            \n            p1$save(file, standalone = TRUE)\n        }\n    )\n    \n    \n    output$chart2 <- renderPlot({\n        plot(density(paracou, sigma=input$sigma), main=\"\")\n    })\n    \n    output$downloadPlot <- downloadHandler(\n        filename = \"density.pdf\",\n        # a function that actually opens a connection to a pdf and print the result to it\n        content = function(file) { # this function must take at least an input variable, namely the filename of the file to save\n            pdf(file,onefile=T, width=12,height=8)\n            plot(density(paracou, sigma=input$sigma), main=\"\")\n            dev.off()\n        }\n    )\n    \n    output$chart_pcf <- renderPlot({\n        if(input$button_pcf == 0 ) return( msgRunPrompt() )\n        input$button_pcf\n        isolate(plot(envelope(Y=paracou, fun=pcf, r=0:input$r_pcf, nsim=input$nsim_pcf, nrank=input$nrank_pcf, stoyan=input$stoyan_pcf), main=\"\", legendpos=\"topleft\", legendargs=list(cex=0.7), xlim=c(0, max(input$r_pcf))))\n    })\n    \n    output$pcfPlot <- downloadHandler(\n        filename = \"pcf.pdf\",\n        # a function that actually opens a connection to a pdf and print the result to it\n        content = function(file) { # this function must take at least an input variable, namely the filename of the file to save\n            pdf(file,onefile=T, width=12,height=8)\n            isolate(plot(envelope(Y=paracou, fun=pcf, r=0:input$r_pcf, nsim=input$nsim_pcf, nrank=input$nrank_pcf, stoyan=input$stoyan_pcf), main=\"\", legendpos=\"topleft\", legendargs=list(cex=0.7), xlim=c(0, max(input$r_pcf))))\n            dev.off()\n        }\n    )\n    \n    output$chart_gest <- renderPlot({\n        if(input$button_gest == 0 ) return( msgRunPrompt() )\n        input$button_gest\n        isolate(plot(envelope(paracou, fun=Gest, r=0:input$r_gest, nsim = input$nsim_gest, nrank=input$nrank_gest), main=\"\", legendpos=\"topleft\", legendargs=list(cex=0.7), xlim=c(0, max(input$r_gest))))\n    })\n    \n    output$gestPlot <- downloadHandler(\n        filename = \"gest.pdf\",\n        # a function that actually opens a connection to a pdf and print the result to it\n        content = function(file) { # this function must take at least an input variable, namely the filename of the file to save\n            pdf(file,onefile=T, width=12,height=8)\n            isolate(plot(envelope(paracou, fun=Gest, r=0:input$r_gest, nsim = input$nsim_gest, nrank=input$nrank_gest), main=\"\", legendpos=\"topleft\", legendargs=list(cex=0.7), xlim=c(0, max(input$r_gest))))\n            dev.off()\n        }\n    )\n    \n    output$chart_lest <- renderPlot({\n        if(input$button_lest == 0 ) return( msgRunPrompt() )\n        input$button_lest\n        isolate(plot(envelope(paracou, fun=Lest, r=0:input$r_lest, nsim = input$nsim_lest, nrank=input$nrank_lest), . -r ~ r, main=\"\", legendpos=\"topleft\", legendargs=list(cex=0.7), xlim=c(0, max(input$r_lest))))\n    })\n    \n    output$lestPlot <- downloadHandler(\n        filename = \"lest.pdf\",\n        # a function that actually opens a connection to a pdf and print the result to it\n        content = function(file) { # this function must take at least an input variable, namely the filename of the file to save\n            pdf(file,onefile=T, width=12,height=8)\n            isolate(plot(envelope(paracou, fun=Lest, r=0:input$r_lest, nsim = input$nsim_lest, nrank=input$nrank_lest), . -r ~ r, main=\"\", legendpos=\"topleft\", legendargs=list(cex=0.7), xlim=c(0, max(input$r_lest))))\n            dev.off()\n        }\n    )\n    \n    output$chart_markcorr <- renderPlot({\n        if(input$button_markcorr == 0 ) return( msgRunPrompt() )\n        input$button_markcorr\n        isolate(plot(envelope(Y=paracou, fun=markcorr, r=0:input$r_markcorr, stoyan=input$stoyan_markcorr, nsim=input$nsim_markcorr,\n                              nrank=input$nrank_markcorr, simulate=expression(rlabel(paracou))), main=\"\", legendpos=\"topleft\",\n                              legendargs=list(cex=0.7), xlim=c(0, max(input$r_markcorr))))\n    })\n    \n    output$markcorrPlot <- downloadHandler(\n        filename = \"markcorr.pdf\",\n        # a function that actually opens a connection to a pdf and print the result to it\n        content = function(file) { # this function must take at least an input variable, namely the filename of the file to save\n            pdf(file,onefile=T, width=12,height=8)\n            isolate(plot(envelope(Y=paracou, fun=markcorr, r=0:input$r_markcorr, stoyan=input$stoyan_markcorr, nsim=input$nsim_markcorr,\n                                  nrank=input$nrank_markcorr, simulate=expression(rlabel(paracou))), main=\"\", legendpos=\"topleft\",\n                         legendargs=list(cex=0.7), xlim=c(0, max(input$r_markcorr))))\n            dev.off()\n        }\n    )\n    \n    output$chart_pcfcross <- renderPlot({\n        if(input$button_pcfcross == 0 ) return( msgRunPrompt() )\n        input$button_pcfcross\n        isolate(plot(envelope(Y=paracou, fun=pcfcross, i=\"adult\", j=\"juvenile\", r=0:input$r_pcfcross,\n                              simulate=expression(rshift(paracou, which=\"adult\")), nsim=input$nsim_pcfcross, nrank=input$nrank_pcfcross,\n                              stoyan=input$stoyan_pcfcross, verbose=FALSE), main=\"\", legendpos=\"topleft\",\n                     legendargs=list(cex=0.7), xlim=c(0, max(input$r_pcfcross))))\n    })\n    \n    output$pcfcrossPlot <- downloadHandler(\n        filename = \"pcfcross.pdf\",\n        # a function that actually opens a connection to a pdf and print the result to it\n        content = function(file) { # this function must take at least an input variable, namely the filename of the file to save\n            pdf(file,onefile=T, width=12,height=8)\n            isolate(plot(envelope(Y=paracou, fun=pcfcross, i=\"adult\", j=\"juvenile\", r=0:input$r_pcfcross,\n                                  simulate=expression(rshift(paracou, which=\"adult\")), nsim=input$nsim_pcfcross, nrank=input$nrank_pcfcross,\n                                  stoyan=input$stoyan_pcfcross, verbose=FALSE), main=\"\", legendpos=\"topleft\",\n                         legendargs=list(cex=0.7), xlim=c(0, max(input$r_pcfcross))))\n            dev.off()\n        }\n    )\n    \n    output$heatmap <- renderChart2({\n        \n        qc <- quadratcount(paracou, nx= input$nx, ny= input$ny)\n        qc_mat <- as.data.frame(qc)\n        qc_mat <- cbind(qc_mat[,2],qc_mat[,1],qc_mat[,3])\n        colnames(qc_mat) <- c(\"x\",\"y\",\"value\")\n        \n        \n        map <- Highcharts$new()\n        map$chart(zoomType = \"x\", type = 'heatmap')\n        map$credits(text = \"Created with rCharts and Highcharts\", href = \"http://rcharts.io\")\n        map$title(text='4x5 Quadrat counting')\n        \n        map$series(name = 'Counts per quadrat',\n                   data = toJSONArray2(qc_mat, json=FALSE),\n                   color = \"#cccccc\",\n                   dataLabels = list(\n                       enabled = TRUE,\n                       color = 'black',\n                       style = list(\n                           textShadow = 'none',\n                           HcTextStroke = NULL\n                       )\n                   ))\n\n        map$addParams(colorAxis = \n                          list(\n                              min = 0,\n                              minColor='#FFFFFF',\n                              maxColor='#7cb5ec'\n                          )\n        )\n        \n        map$legend(align='right',\n                   layout='vertical',\n                   margin=0,\n                   verticalAlign='top',\n                   y=25,\n                   symbolHeight=320)\n        \n        # set width and height of the plot and attach it to the DOM\n        map$addParams(height = 400, width=1000, dom=\"heatmap\")\n        \n        # save heatmap as HTML page heatmap.html for debugging\n        #map$save(destfile = 'heatmap.html')\n        \n        # print map\n        print(map)\n    })\n    \n    \n    output$heatPlot <- downloadHandler(\n        filename = \"scatterplot.html\",\n        # a function that actually opens a connection to a pdf and print the result to it\n        content = function(file) { # this function must take at least an input variable, namely the filename of the file to save\n            \n            qc <- quadratcount(paracou, nx= input$nx, ny= input$ny)\n            qc_mat <- as.data.frame(qc)\n            qc_mat <- cbind(qc_mat[,2],qc_mat[,1],qc_mat[,3])\n            colnames(qc_mat) <- c(\"x\",\"y\",\"value\")\n            \n            \n            map <- Highcharts$new()\n            map$chart(zoomType = \"x\", type = 'heatmap')\n            map$credits(text = \"Created with rCharts and Highcharts\", href = \"http://rcharts.io\")\n            map$title(text='4x5 Quadrat counting')\n            \n            map$series(name = 'Counts per quadrat',\n                       data = toJSONArray2(qc_mat, json=FALSE),\n                       color = \"#cccccc\",\n                       dataLabels = list(\n                           enabled = TRUE,\n                           color = 'black',\n                           style = list(\n                               textShadow = 'none',\n                               HcTextStroke = NULL\n                           )\n                       ))\n            \n            map$addParams(colorAxis = \n                              list(\n                                  min = 0,\n                                  minColor='#FFFFFF',\n                                  maxColor='#7cb5ec'\n                              )\n            )\n            \n            map$legend(align='right',\n                       layout='vertical',\n                       margin=0,\n                       verticalAlign='top',\n                       y=25,\n                       symbolHeight=320)\n            \n            # set width and height of the plot and attach it to the DOM\n            map$addParams(height = 400, width=1000, dom=\"heatmap\")\n            \n            # save heatmap as HTML page heatmap.html for debugging\n            map$save(file, standalone = TRUE)\n        }\n    )\n    \n    output$myMap <- renderLeaflet(\n        leaflet() %>%\n            \n            # Add tiles as baseGroup\n            addProviderTiles(\"OpenMapSurfer.Roads\", group = \"OpenMapSurfer.Roads\") %>%\n            \n            # Layers control\n            addLayersControl(\n                baseGroups = c(\"OpenMapSurfer.Roads\"),\n                overlayGroups = c(\"Trees\"),\n                options = layersControlOptions(collapsed = FALSE)\n            ) %>%\n            \n            # add trees\n            addMarkers(data = random_points, \n                       lat = ~ y, \n                       lng = ~ x, \n                       popup = marks,\n                       group=\"Trees\")\n        \n    )\n\n    output$summary <- renderPrint({\n        summary(point.data)\n    })\n    \n    output$summary2 <- renderPrint({\n        summary(point.data)\n    })\n    \n    output$table <- renderDataTable({\n        point.data\n    }, options=list(pageLength=10))\n    \n})",
    "created" : 1438247230851.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "939523245",
    "id" : "79E78A86",
    "lastKnownWriteTime" : 1438282374,
    "path" : "~/Documents/spatstat/dist/shiny/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}